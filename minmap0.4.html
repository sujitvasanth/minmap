<!DOCTYPE html><html>
  <head><title>Mind Map</title><style>canvas {border: 1px solid black;touch-action: none;}</style></head>
  <body>
    <script src="https://unpkg.com/dropbox@4.0.30/dist/Dropbox-sdk.min.js"></script>
    <script>
      function createElement(tag, attributes, textContent) {
        const element = document.createElement(tag);
        for (const key in attributes) {element.setAttribute(key, attributes[key]);}
        if (textContent) {element.textContent = textContent;}
        document.body.appendChild(element);return element;} 
      const canvas = createElement('canvas', { id: 'canvas', width: (window.innerWidth * 0.98).toString(), height: (window.innerHeight * 0.98).toString(), style: 'background-color: #fdf7ed; border: 1px solid black; touch-action: none;' });
      const hiddenInput = createElement('textarea', { id: 'hidden-input', style: 'opacity: 0; position: absolute; top: 20px; left: 20px; font-size: 17px; font-family: Arial; border: none; outline: none; text-align: center;', rows: '4', columns: '25' });
      const cutButton = createElement('button', { id: 'cut-button', style: 'position: absolute; top: 10px; right: 10px; width: 6ch; font-size: 14px; display: none;' }, ' Cut ');
      const copyButton = createElement('button', { id: 'copy-button', style: 'position: absolute; top: 10px; right: 10px; width: 6ch; font-size: 14px; display: none;' }, 'Copy');
      const pasteButton = createElement('button', { id: 'paste-button', style: 'position: absolute; top: 10px; right: 10px; width: 6ch; font-size: 14px; display: none;' }, 'Paste');
      const optionsButton = createElement('button', { id: 'options-button', style: 'position: absolute; top: 10px; right: 10px; width: 3.5ch; font-size: 14px; display: none;' }, '...');
      const zoomSlider = createElement('input', { type: 'range', id: 'zoom-slider', min: '0.01', max: '2', step: '0.01', value: '1', style: 'position: absolute; top: 20px; left: 20px; width: 600px; background: transparent;' });
      const authenticateButton = createElement('button', { id: 'authenticate-button', style: 'position: absolute; top: 15px; right: 220px; width: 12ch; font-size: 14px;' }, 'Authenticate');
      const saveButton = createElement('button', { id: 'save-button', style: 'position: absolute; top: 15px; right: 120px; width: 10ch; font-size: 17px;' }, 'SaveCloud');
      const loadButton = createElement('button', { id: 'load-button', style: 'position: absolute; top: 15px; right: 17px; width: 10ch; font-size: 17px;' }, 'LoadCloud');
      const loadLocalButton = createElement('button', { id: 'loadLocal-button', style: 'position: absolute; top: 45px; right: 17px; width: 10ch; font-size: 17px;' }, 'LoadLocal');
      const saveLocalButton = createElement('button', { id: 'saveLocal-button', style: 'position: absolute; top: 45px; right: 120px; width: 10ch; font-size: 17px;' }, 'SaveLocal');
      const context = canvas.getContext("2d");  
      const urlParams = new URLSearchParams(window.location.hash.substring(1));
      const accessToken = urlParams.get("access_token"); if (!accessToken) {saveButton.disabled = true;loadButton.disabled = true;}
      var nodes = [];let selectedNodeIndex = -1; var subtreeindices=[];var nodesclipboard=[];
      const radiusX = 80;const radiusY = 30;const cornerRadius = 18; var name="";
      let lastTouchTime = 0;var lastx=0;var lasty=0;let drag = 0;var pan = false; var lineHeight = 17
      let scale=1.0;var prevDiff = -1;var evCache = new Array(); //for pinch zoom and pointer touch cache
      const colors = ["#e9b6c1","#bfe0f3","#c3e6cb","#ffe4c4",  "#ba94d1", "#73a9ad","#b8b2a6"];
      
      window.addEventListener("resize", displayWindowSize);
      function displayWindowSize() {canvas.width = window.innerWidth -17;canvas.height = window.innerHeight -22;redraw()};
            
      context.font = "30px Arial";context.fillStyle = "black";context.textAlign = "center";
      context.fillText("Minmap", canvas.width/2, canvas.height/6);
      context.font = "10px Arial";context.fillText("Platform Agnostic Mindmaps", canvas.width/2, canvas.height/6+15);
      context.fillText("by Sujit Vasanth", canvas.width/2+20, canvas.height/6+30);
      context.font = "12px Arial";context.fillText("Double-tap", canvas.width/2, canvas.height/6+115);           
      context.beginPath();context.arc(canvas.width/2, canvas.height/6+70, 27, 0, 2*Math.PI);
      context.fillStyle = "#e0b6c1";context.fill();
      context.beginPath();context.lineWidth = 5;context.strokeStyle = "white";
      var length = 25;var x = canvas.width/2;var y = canvas.height/6+70;
      context.moveTo(x - length/2, y);context.lineTo(x + length/2, y);
      context.moveTo(x, y - length/2);context.lineTo(x, y + length/2);context.stroke();
      context.strokeStyle = "black";context.lineWidth = 1;
      
      optionsButton.addEventListener("click", function() {
        const left = optionsButton.style.left; const top = optionsButton.style.top;
        cutButton.style.left = `${parseInt(left) + 20}px`;cutButton.style.top = `${parseInt(top) - 25}px`;
        copyButton.style.left = `${parseInt(left) + 20}px`;copyButton.style.top = `${parseInt(top) - 50}px`;
        pasteButton.style.left = `${parseInt(left) + 20}px`;pasteButton.style.top = `${parseInt(top) - 75}px`;
        if (cutButton.style.display=="none") {menuupdate(1);} else {menuupdate(0);}
      });
            
      pasteButton.addEventListener("click", function() {
        const newnodeindex=nodes.length
        if (selectedNodeIndex !== -1) {  
          nodes[selectedNodeIndex].children.push(newnodeindex);}//if not root node add index of the next node to its parent's list of childnren
        for (var i = 0; i < nodesclipboard.length; i++) {//update all the childrens indices now we know the what clipboard basenode index is
            for (var j = 0; j < nodesclipboard[i].children.length; j++) {
                  var oldIndex = nodesclipboard[i].children[j];
                  nodesclipboard[i].children[j] = oldIndex+newnodeindex;}}  
        for (var i = 0; i < nodesclipboard.length; i++) {//add the amended nodes to the nodes array 
            nodes.push(JSON.parse(JSON.stringify(nodesclipboard[i])));} //create a deep copy of the node
        menuupdate(0);redraw();})              
      
      function menuupdate(state) {
        var display="none"; if (state==1) {display="block"} 
        cutButton.style.display = display;copyButton.style.display = display;
        pasteButton.style.display = display;}
      
      saveLocalButton.addEventListener("click", function() {
        if (nodes.length === 0) {alert("Mindmap is blank so not saved");}     
        else {
          try {localStorage.setItem("nodes", JSON.stringify(nodes));
               alert("File was successfully saved!");}
          catch(e) {alert("Error saving file: " + e);}}
           });    

      loadLocalButton.addEventListener("click", function() {
        const nodesStr = localStorage.getItem("nodes");
        if (nodesStr) {nodes = JSON.parse(nodesStr);selectedNodeIndex = 0;redraw();}});

      saveButton.addEventListener("click", function() {
        const fileName = prompt("Please enter a filename for your Mind Map:", name);
        if (fileName != null) {
          const data = JSON.stringify(nodes);
          const blob = new Blob([data], { type: "application/json" });
          const fileReader = new FileReader();
          fileReader.onloadend = function() {
            const dropbox = new Dropbox.Dropbox({ accessToken: accessToken });
            dropbox.filesUpload({ path: '/Minmap/' + fileName + '.minmap', contents: fileReader.result, mode: 'overwrite' })
              .then(function(response) {alert('File saved to Dropbox');})
              .catch(function(error) {alert('Error saving file to Dropbox: ' + error.message);});};
          fileReader.readAsArrayBuffer(blob);}});

      loadButton.addEventListener('click', () => {
        const dropbox = new Dropbox.Dropbox({ accessToken });
        dropbox.filesListFolder({ path: '/Minmap' })
          .then(({ entries }) => {
            const minmapFiles = entries.filter(file => file.name.endsWith('.minmap'));
            const popup = document.createElement('div');
            popup.style = `position: absolute; z-index: 1; background-color: #007bee; border: 1px solid #ddd; border-radius: 5px; padding: 5px; width: 50%; height: 25%; left: 50%; top: 50%; transform: translate(-50%, -50%);`;
            const popupList = document.createElement('select');
            popupList.style = `padding: 15px; width: 100%; background-color: #fff; color: #000; font-size: 18px; border: 1px solid #ccc;`;
            popupList.size = 5;
            popupList.append(...minmapFiles.map(({ path_lower, name }) => {
              const option = document.createElement('option');
              option.value = path_lower;
              option.textContent = name.slice(0, -7);
              return option;}));
            const selectButton = document.createElement('button');
            selectButton.textContent = 'Open';
            selectButton.style = `margin-right: 10px; font-size: 18px;`;
            selectButton.addEventListener('click', () => {
              const selected = popupList.querySelector('option:checked');
              if (selected) {
                name = selected.textContent;
                dropbox.filesDownload({ path: selected.value })
                  .then(function(response) {
                    const blob = new Blob([response.fileBlob], { type: "application/json" });
                    const reader = new FileReader();
                    reader.onload = function(event) {
                      const data = JSON.parse(event.target.result);
                      nodes = data;selectedNodeIndex = 0;redraw();};
                    reader.readAsText(blob);})
                  .catch(({ message }) => alert(`Error loading file from Dropbox: ${message}`));
                document.body.removeChild(popup);
              } else {alert('Please select a file.');}});
            const cancelButton = document.createElement('button');
            cancelButton.textContent = 'Cancel';
            cancelButton.style = `font-size: 18px;`;
            cancelButton.addEventListener('click', () => document.body.removeChild(popup));
            popup.append(popupList, selectButton, cancelButton);
            document.body.appendChild(popup);})
          .catch(({ message }) => alert(`Error listing files in Dropbox: ${message}`));});

      authenticateButton.addEventListener("click", function() {
        const appKey = 'uyt17co0totx5rx';// Replace 'YOUR_APP_KEY' with your Dropbox app key
        var redirectUri = 'https://minmap.vercel.app';
        if (window.location.protocol === 'file:') {redirectUri = 'http://localhost/minmap0.4.html';}
        let dbx = new Dropbox.Dropbox({ clientId: appKey });
        window.location.href = dbx.getAuthenticationUrl(redirectUri);});

      function drawNode(node) {
        context.beginPath();
        var nodelabel = node.label
        const generation = countIterations(nodes.indexOf(node), 0);
        const generationScale = Math.pow(0.94, generation);        
        const rectWidth = radiusX * 2 * scale * generationScale;
        const rectHeight = radiusY * 2 * scale * generationScale;
        context.font = `${lineHeight*scale* generationScale}px Arial`;
                
        const lines = nodelabel.split("\n");
        var maxLabelWidth = 50*scale*generationScale;
        var pad = 20*scale*generationScale;
        for (let i = 0; i < lines.length; i++) {
          const lineWidth = context.measureText(lines[i]).width;
          if (lineWidth > maxLabelWidth) {maxLabelWidth = lineWidth;}}
        maxLabelWidth += pad;
        const y2 = (node.y - (lineHeight*generationScale * (lines.length+1)) / 2)*scale;

        function drawRoundedRect(x, y, width, height) {
          context.beginPath();context.moveTo(x + cornerRadius*scale*generationScale, y);
          context.lineTo(x + width - cornerRadius*scale*generationScale, y);
          context.quadraticCurveTo(x + width, y, x + width, y + cornerRadius*scale*generationScale);
          context.lineTo(x + width, y + height - cornerRadius*scale*generationScale);
          context.quadraticCurveTo(x + width, y + height, x + width - cornerRadius*scale*generationScale, y + height);
          context.lineTo(x + cornerRadius*scale*generationScale, y + height);
          context.quadraticCurveTo(x, y + height, x, y + height - cornerRadius*scale*generationScale);
          context.lineTo(x, y + cornerRadius*scale*generationScale); context.quadraticCurveTo(x, y, x + cornerRadius*scale*generationScale, y);
          context.closePath();}
        
        drawRoundedRect(node.x * scale -  maxLabelWidth / 2, y2,  maxLabelWidth, (lines.length+1)*lineHeight*scale*generationScale);//draw the node outline
        context.fillStyle = colors[generation];context.fill();context.stroke();
        
        context.textAlign = "center";context.fillStyle = "black";//write the node text
        const y = (node.y - (lineHeight * (lines.length-1.5)) / 2)*scale;
        lines.forEach((line, i) => {context.fillText(line, node.x*scale, y + i * lineHeight*scale);});
        
        if (nodes.indexOf(node) === selectedNodeIndex && drag==0){//place the cursor        
          const cursorPos = hiddenInput.selectionStart;
          const labelBeforeCursor = nodes[selectedNodeIndex].label.slice(0, cursorPos);           
          const linesBeforeCursor = labelBeforeCursor.split("\n");
          const cursorline = linesBeforeCursor.length-1;
          const lineOfCursor = linesBeforeCursor[cursorline]
          const totallines = lines.length-1
          const cursorY = (node.y + (lineHeight *( ((totallines-1) / 2)-(totallines-cursorline)) ) )* scale;
          const wholeLabelWidth = context.measureText(lines[cursorline]).width;
          const labelBeforeCursorWidth = context.measureText(lineOfCursor).width;
          const cursorX = (node.x)* scale +labelBeforeCursorWidth - wholeLabelWidth/2;
          context.beginPath();context.moveTo(cursorX, cursorY);
          context.lineTo(cursorX, cursorY + lineHeight*scale* generationScale);
          context.stroke();}
          
        if (nodes.indexOf(node) === selectedNodeIndex){
          context.lineWidth = 1;
          context.setLineDash([8*scale, 11*scale]);
          context.beginPath();
          drawRoundedRect(node.x * scale - maxLabelWidth / 2 - 5, y2 - 5, (maxLabelWidth + 10), ((lines.length+1)*lineHeight*scale*generationScale) + 10);
          context.stroke();
          context.beginPath();
          context.lineWidth = 1;
          context.setLineDash([]);
          const optionsButtonX = (node.x*scale) + maxLabelWidth/2;  
          const optionsButtonY = node.y*scale + (lines.length+2)*lineHeight*scale*generationScale*0.5;
          if (optionsButtonX>canvas.width-50) {
            optionsButton.style.display = "none";
            menuupdate(0);
          } else {
          optionsButton.style.left = `${optionsButtonX}px`;
          optionsButton.style.top = `${optionsButtonY}px`;
          optionsButton.style.display = "block";
          if (cutButton.style.display=="block") {
            const left = optionsButton.style.left; const top = optionsButton.style.top;
            cutButton.style.left = `${parseInt(left) + 20}px`;cutButton.style.top = `${parseInt(top) - 25}px`;
            copyButton.style.left = `${parseInt(left) + 20}px`;copyButton.style.top = `${parseInt(top) - 50}px`;
            pasteButton.style.left = `${parseInt(left) + 20}px`;pasteButton.style.top = `${parseInt(top) - 75}px`;}};}  
          }

      function countIterations(index, iteration) {
        if (index === 0) return iteration;
        const parentIndex = nodes.findIndex((node) => node.children.includes(index));
        return countIterations(parentIndex, iteration + 1);}
          
      function addNode(x, y) {
        const node = { x, y, label: "", children: [] };
        if (selectedNodeIndex !== -1) {nodes[selectedNodeIndex].children.push(nodes.length);}
        nodes.push(node); selectedNodeIndex = nodes.length - 1; // set selectedNodeIndex to new node
        hiddenInput.value = "";redraw();}

      function redraw() {
        context.clearRect(0, 0, canvas.width, canvas.height);
        if (selectedNodeIndex == -1) {optionsButton.style.display = "none";return;}
        nodes.forEach((node, index) => {
          node.children.forEach((childIndex) => {
            const child = nodes[childIndex];
            context.beginPath(); //draw the connector
            context.moveTo(node.x*scale, node.y*scale);
            context.lineTo(child.x*scale, child.y*scale);
            context.stroke();});
            drawNode(node);})}; //draw the node

      function handlePointerDown(event) {
        evCache.push(event);
        for (var i = 0; i < evCache.length; i++) {
          if (event.pointerId === evCache[i].pointerId) {
            evCache[i] = event;}}
        const rect = canvas.getBoundingClientRect();
        const x = (event.clientX - rect.left)/scale;
        const y = (event.clientY - rect.top)/scale;
        const node = nodes.find(
          (node) => x >= node.x - radiusX && x <= node.x + radiusX &&
                    y >= node.y - radiusY && y <= node.y + radiusY);                
        event.preventDefault();
        const currentTime = new Date().getTime();
        const tapLength = currentTime - lastTouchTime;
        lastTouchTime = currentTime;
        if (tapLength < 250 && tapLength > 100) {//double click event
          hiddenInput.focus(); 
          if (node) {
            var ev = document.createEvent('HTMLEvents');
          } else {
            if (evCache.length==1) {
            addNode(x, y);redraw()}}
        } else {
          if (node) {
            pan=false
            selectedNodeIndex = nodes.indexOf(node);   
            hiddenInput.value=node.label;
            redraw();drag=1
          } else {
            pan=true;drag=1;}}
        lastx=x;lasty=y;}

      function handlePointerMove(event) {
        event.preventDefault();
        for (var i = 0; i < evCache.length; i++) {
          if (event.pointerId === evCache[i].pointerId) {
            evCache[i] = event;}}
        if (evCache.length > 1)  {
          drag=0;
          var curDiff = Math.sqrt(Math.pow(evCache[1].clientX - evCache[0].clientX, 2) + Math.pow(evCache[1].clientY - evCache[0].clientY, 2));
          const oldscale=scale
          if (prevDiff > 0) {scale += 0.01*(curDiff-prevDiff);};
          if (scale < 0) {scale=oldscale;}; pan=1;
          moveNode(0 ,(canvas.width*0.5*oldscale/scale-canvas.width*0.5)/oldscale,
            (canvas.height*0.5*oldscale/scale-canvas.height*0.5)/oldscale);
          prevDiff = curDiff;
          zoomSlider.value = scale;
          event=evCache[0];
          redraw();}
        else if (drag) {
          if (selectedNodeIndex == -1) {return;}
          const rect = canvas.getBoundingClientRect();
          const x = (event.clientX - rect.left)/scale;const y = (event.clientY - rect.top)/scale;
          const dx = x - lastx;const dy = y - lasty;
          if (pan ==false) {
          moveNode(selectedNodeIndex , dx, dy);
          hiddenInput.blur();}
          else {moveNode(0 , dx, dy);}
          lastx=x;lasty=y;
          redraw();}}

      function moveNode(index, dx, dy) {
        nodes[index].x += dx;nodes[index].y += dy;
        if (index!=0 || pan==1) {nodes[index].children.forEach((childIndex) => {moveNode(childIndex, dx, dy);});}}
      
      function cutSelectedNode(event) { 
        subtreeindices.splice(0); //initialise list of nodes to remove        
        findSubtree(selectedNodeIndex); //get array of subtreeindices
        subtreeindices.push(selectedNodeIndex);subtreeindices.sort((a, b) => b - a);
        nodesclipboard=[];
        for (var i = subtreeindices.length - 1; i >= 0; i--) {//copy the subtree nodes to clipboard 
          nodesclipboard.push(JSON.parse(JSON.stringify(nodes[subtreeindices[i]])));}//create a deep copy of the node
          for (var i = 0; i < nodesclipboard.length; i++) {//and renumber the children
             for (var j = 0; j < nodesclipboard[i].children.length; j++) {
                  var oldIndex = nodesclipboard[i].children[j];
                  nodesclipboard[i].children[j] = subtreeindices.length -1 - subtreeindices.indexOf(oldIndex);}}
        if (event.target.textContent ===" Cut ") {//delete the subtree nodes and renumber the children
          if (selectedNodeIndex == 0) {nodes.splice(0);selectedNodeIndex = -1;}
          else{  const prentNodeIndex = nodes.findIndex((prent) => prent.children.includes(selectedNodeIndex));          
                 const nodeChildIndex = nodes[prentNodeIndex].children.indexOf(selectedNodeIndex);
                 nodes[prentNodeIndex].children.splice(nodeChildIndex, 1);
                 selectedNodeIndex = prentNodeIndex;
                 for (var i = 0; i < subtreeindices.length; i++) {
                   nodes.splice(subtreeindices[i], 1);
                   nodes.forEach((node) => {
                     for (var j = 0; j < node.children.length; j++) {
                       if (node.children[j] > subtreeindices[i]) {node.children[j]--;}}});}}}           
        redraw();menuupdate(0);}
          
      function findSubtree(index) {
        nodes[index].children.forEach((childIndex) => {subtreeindices.push(childIndex);findSubtree(childIndex);});}
          
      function handlePointerUp(event) {
        event.preventDefault();pan=0;
        if (evCache.length < 2) {prevDiff = -1;drag=0;};
        for (var i = 0; i < evCache.length; i++) {
          if (evCache[i].pointerId == event.pointerId) {
            evCache.splice(i, 1);}}
        evCache=[]}//stops various ui bugs on mobile when screen turns off/sleeps
            
      function handleKeys(event) {if (selectedNodeIndex !== -1) {nodes[selectedNodeIndex].label = hiddenInput.value;redraw();}}   
      canvas.addEventListener("pointerdown", handlePointerDown);canvas.addEventListener("pointermove", handlePointerMove);
      canvas.addEventListener("pointerup", handlePointerUp);canvas.addEventListener("mouseout", handlePointerUp); 
      hiddenInput.addEventListener('keydown', handleKeys);hiddenInput.addEventListener("keyup", handleKeys);
      cutButton.addEventListener("click", cutSelectedNode);copyButton.addEventListener("click", cutSelectedNode);
      zoomSlider.addEventListener("input", function() {
        const oldscale=scale
        scale = parseFloat(this.value); pan=1;
        moveNode(0 ,(canvas.width*0.5*oldscale/scale-canvas.width*0.5)/oldscale,
          (canvas.height*0.5*oldscale/scale-canvas.height*0.5)/oldscale);
        redraw();}); 
      canvas.addEventListener('wheel', function(event) {
           event.preventDefault();
           const delta = Math.sign(event.deltaY);
           const oldscale=scale
           if (delta === 1) {scale *= 1.05;}
           else if (delta === -1) {scale /= 1.05;}
           pan=1;
           moveNode(0 ,(canvas.width*0.5*oldscale/scale-canvas.width*0.5)/oldscale,
              (canvas.height*0.5*oldscale/scale-canvas.height*0.5)/oldscale);
           zoomSlider.value = scale;
           redraw();});
    </script></body></html>
