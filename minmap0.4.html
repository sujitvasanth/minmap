<!DOCTYPE html>
<html>
  <head>
    <title>Mind Map</title>
    <style>
      canvas {
        border: 1px solid black;
        touch-action: none;
      }
    </style>
    <script src="https://unpkg.com/dropbox@4.0.30/dist/Dropbox-sdk.min.js"></script>
  </head>
  <body>
   <canvas id="canvas" width="600" height="300"></canvas>
   <textarea id="hidden-input" style="opacity: 0; position: absolute; top: 20px; left: 20px; font-size: 17px; font-family: Arial; border: none; outline: none; text-align: center;" rows="4" columns="25"></textarea>
   <button id="delete-button" style="position: absolute; top: 10px; right: 10px; width: 5.5ch; font-size: 17px; display: none; "> Del </button>
   <input type="range" id="zoom-slider" min="0.01" max="2" step="0.01" value="1"; style="position: absolute; top: 20px; left: 20px; width: 600px">
   <button id="authenticate-button" style="position: absolute; top: 10px; right: 170px; width: 10ch; font-size: 17px;">Authenticate</button>
   <button id="save-button" style="position: absolute; top: 10px; right: 90px; width: 6ch; font-size: 17px;">Save</button>
   <button id="load-button" style="position: absolute; top: 10px; right: 10px; width: 6ch; font-size: 17px;">Load</button>

    <script>
      const canvas = document.getElementById("canvas");
      const context = canvas.getContext("2d");
      canvas.width = (window.innerWidth)*0.98;
      canvas.height = (window.innerHeight)*0.98;  
      canvas.style.backgroundColor = "#fdf7ed";//"#fff0ef"; //"#fffbe0"; //"#fff5d7"; //"#ebebf0";        
      const hiddenInput = document.getElementById('hidden-input');
      const deleteButton = document.getElementById("delete-button");
      const zoomSlider = document.getElementById("zoom-slider");
      zoomSlider.style.background = "transparent";
      const fileInput = document.getElementById("file-input");
      const saveButton = document.getElementById("save-button");
      const loadButton = document.getElementById("load-button");
      const authenticateButton = document.getElementById("authenticate-button");
      const urlParams = new URLSearchParams(window.location.hash.substring(1));
      const accessToken = urlParams.get("access_token");
      if (accessToken) {authenticateButton.style.display = "none";}
      else {saveButton.disabled = true;loadButton.disabled = true;}
      var nodes = [];let selectedNodeIndex = -1; 
      let lastTouchTime = 0;let drag = 0;
      const radiusX = 80;const radiusY = 30;
      const cornerRadius = 18;
      var torm=[];let scale=1.0;
      var lastx=0;var lasty=0;
      var prevDiff = -1;//for pinch zoom
      var evCache = new Array(); //for pointer touch cache
      var pan = false
  
      saveButton.addEventListener("click", function() {
        const fileName = prompt("Please enter a filename for your Mind Map:", "mindmap");
        if (fileName != null) {
          const data = JSON.stringify(nodes);
          const blob = new Blob([data], { type: "application/json" });
          const fileReader = new FileReader();
          fileReader.onloadend = function() {
            const dropbox = new Dropbox.Dropbox({ accessToken: accessToken });
            dropbox.filesUpload({ path: '/Minmap/' + fileName + '.minmap', contents: fileReader.result, mode: 'overwrite' })
              .then(function(response) {alert('File saved to Dropbox');})
              .catch(function(error) {alert('Error saving file to Dropbox: ' + error.message);});};
          fileReader.readAsArrayBuffer(blob);}});

      loadButton.addEventListener('click', function() {
        const dropbox = new Dropbox.Dropbox({ accessToken: accessToken });
        dropbox.filesListFolder({path: '/Minmap'})
          .then(function(response) {
            const minmapFiles = response.entries.filter(function(file) {
              return file.name.endsWith('.minmap');
            });

            const popup = document.createElement('div');
            popup.style.position = 'absolute';
            popup.style.zIndex = '1';
            popup.style.backgroundColor = '#007bee';
            popup.style.border = '1px solid #ddd';
            popup.style.borderRadius = '5px';
            popup.style.padding = '5px';
            popup.style.width = '50%';
            popup.style.height = '25%';
            popup.style.left = '50%';
            popup.style.top = '50%';
            popup.style.transform = 'translate(-50%, -50%)';

            const popupList = document.createElement('select');
            popupList.style.padding = '15px';
            popupList.style.width = '100%';
            popupList.style.backgroundColor = '#fff';
            popupList.style.color = '#000';
            popupList.style.fontSize = '18px';
            popupList.style.border = '1px solid #ccc';
            popupList.size = 5;

            minmapFiles.forEach(function(file) {
              const option = document.createElement('option');
              option.value = file.path_lower;
              option.textContent = file.name;
              popupList.appendChild(option);
            });

            const selectButton = document.createElement('button');
            selectButton.textContent = 'Open';
            selectButton.style.marginRight = '10px';
            selectButton.style.fontSize = '18px';
            selectButton.addEventListener('click', function() {
              const selected = popupList.querySelector('option:checked');
              if (selected) {
                dropbox.filesDownload({ path: selected.value })
                  .then(function(response) {
                    const blob = new Blob([response.fileBlob], { type: "application/json" });
                    const reader = new FileReader();
                    reader.onload = function(event) {
                      const data = JSON.parse(event.target.result);
                      nodes = data;
                      selectedNodeIndex = 0;
                      redraw();
                    };
                    reader.readAsText(blob);
                  })
                  .catch(function(error) {
                    alert('Error loading file from Dropbox: ' + error.message);
                  });
                document.body.removeChild(popup);
              } else {
                alert('Please select a file.');
              }
            });

      const cancelButton = document.createElement('button');
      cancelButton.textContent = 'Cancel';
      selectButton.style.fontSize = '18px';
      cancelButton.addEventListener('click', function() {
        document.body.removeChild(popup);
      });

      popup.appendChild(popupList);
      popup.appendChild(selectButton);
      popup.appendChild(cancelButton);
      document.body.appendChild(popup);

    })
    .catch(function(error) {
      alert('Error listing files in Dropbox: ' + error.message);
    });
});
      authenticateButton.addEventListener("click", function() {
        // Replace 'YOUR_APP_KEY' with your Dropbox app key
        const appKey = 'uyt17co0totx5rx';
        var redirectUri = 'https://minmap.vercel.app';
        if (window.location.protocol === 'file:') {redirectUri = 'http://localhost/minmap0.4.html';}
        let dbx = new Dropbox.Dropbox({ clientId: appKey });
        window.location.href = dbx.getAuthenticationUrl(redirectUri);
      });

  
      function drawNode(node) {
        var lineHeight = 17
        context.beginPath();
        var nodelabel = node.label
        const generation = countIterations(nodes.indexOf(node), 0);
        const generationScale = Math.pow(0.9, generation);        
        const rectWidth = radiusX * 2 * scale * generationScale;
        const rectHeight = radiusY * 2 * scale * generationScale;
        const colors = ["#e0b6c1","#bfe0ef","#c3e6cb",   "#ffe4c4",  "#ffdab9"];
        
        function drawRoundedRect(x, y, width, height) {
          context.beginPath();context.moveTo(x + cornerRadius*scale*generationScale, y);
          context.lineTo(x + width - cornerRadius*scale*generationScale, y);
          context.quadraticCurveTo(x + width, y, x + width, y + cornerRadius*scale*generationScale);
          context.lineTo(x + width, y + height - cornerRadius*scale*generationScale);
          context.quadraticCurveTo(x + width, y + height, x + width - cornerRadius*scale*generationScale, y + height);
          context.lineTo(x + cornerRadius*scale*generationScale, y + height);
          context.quadraticCurveTo(x, y + height, x, y + height - cornerRadius*scale*generationScale);
          context.lineTo(x, y + cornerRadius*scale*generationScale); context.quadraticCurveTo(x, y, x + cornerRadius*scale*generationScale, y);
          context.closePath();}  
        
        const lines = nodelabel.split("\n");
        var maxLabelWidth = 50*scale*generationScale;
        var pad = 20*scale*generationScale
        if (generation == 0) { //root node styling
          context.font = `${23*scale}px Arial`;
          maxLabelWidth = 70*scale
          } else { //other node styling
          context.font = `${17*scale* generationScale}px Arial`;
          };
          for (let i = 0; i < lines.length; i++) {
            const lineWidth = context.measureText(lines[i]).width;
            if (lineWidth > maxLabelWidth) {maxLabelWidth = lineWidth;}}
          maxLabelWidth += pad;
          const y2 = (node.y - (lineHeight*generationScale * (lines.length+1)) / 2)*scale;
        
        if (nodes.indexOf(node) === selectedNodeIndex){
          context.lineWidth = 1;
          context.setLineDash([8, 11]);
          context.beginPath();
          drawRoundedRect(node.x * scale - maxLabelWidth / 2 - 5, y2 - 5, (maxLabelWidth + 10), ((lines.length+1)*lineHeight*scale*generationScale) + 10);
          context.stroke();
          context.beginPath();
          context.lineWidth = 1;
          context.setLineDash([]);
          const deleteButtonX = (node.x*scale) + (rectWidth/2) +10;
          const deleteButtonY = (node.y*scale) - (rectHeight/2) - 20;
          deleteButton.style.left = `${deleteButtonX}px`;
          deleteButton.style.top = `${deleteButtonY}px`;
          deleteButton.style.display = "block";
        }
        
       drawRoundedRect(node.x * scale -  maxLabelWidth / 2, y2,  maxLabelWidth, (lines.length+1)*lineHeight*scale*generationScale);
       context.fillStyle = colors[generation]
       context.fill();
       context.stroke();

        if (nodes.indexOf(node) === 0) { //root node styling
          context.font = `${20*scale}px Arial`;
          lineHeight = 20;
        } else { //other node styling
          context.font = `${17*scale* generationScale}px Arial`;
          lineHeight = 17;
        };
        
        context.textAlign = "center";
        context.fillStyle = "black";
        const y = (node.y - (lineHeight * (lines.length-1.5)) / 2)*scale;
        lines.forEach((line, i) => {context.fillText(line, node.x*scale, y + i * lineHeight*scale);});
        
        if (nodes.indexOf(node) === selectedNodeIndex){        
          const cursorPos = hiddenInput.selectionStart;
          const labelBeforeCursor = nodes[selectedNodeIndex].label.slice(0, cursorPos);           
          const linesBeforeCursor = labelBeforeCursor.split("\n");
          const cursorline = linesBeforeCursor.length-1;
          const lineOfCursor = linesBeforeCursor[cursorline]
          const totallines = lines.length-1
          const cursorY = (node.y + (lineHeight *( ((totallines-1) / 2)-(totallines-cursorline)) ) )* scale;
          const wholeLabelWidth = context.measureText(lines[cursorline]).width;
          const labelBeforeCursorWidth = context.measureText(lineOfCursor).width;
          const cursorX = (node.x)* scale +labelBeforeCursorWidth - wholeLabelWidth/2;
          context.beginPath();
          context.moveTo(cursorX, cursorY);
          context.lineTo(cursorX, cursorY + lineHeight*scale* generationScale);
          context.stroke();
        }
      }

      function countIterations(index, iteration) {
        if (index === 0) return iteration;
        const parentIndex = nodes.findIndex((node) => node.children.includes(index));
        return countIterations(parentIndex, iteration + 1);}
          
      function addNode(x, y) {
        const node = { x, y, label: "", children: [] };
        if (selectedNodeIndex !== -1) {nodes[selectedNodeIndex].children.push(nodes.length);}
        nodes.push(node);
        selectedNodeIndex = nodes.length - 1; // set the selectedNodeIndex to the index of the new node
        hiddenInput.value = "";redraw();}

      function redraw() {
        context.clearRect(0, 0, canvas.width, canvas.height);
        if (selectedNodeIndex === -1) {deleteButton.style.display = "none";return;}
        nodes.forEach((node, index) => {
          node.children.forEach((childIndex) => {
            const child = nodes[childIndex];
            context.beginPath(); //draw the connector
            context.moveTo(node.x*scale, node.y*scale);
            context.lineTo(child.x*scale, child.y*scale);
            context.stroke();
          });
        drawNode(node);})}; //draw the node}

      function handlePointerDown(event) {
        evCache.push(event);
        for (var i = 0; i < evCache.length; i++) {
          if (event.pointerId === evCache[i].pointerId) {
            evCache[i] = event;}}
        const rect = canvas.getBoundingClientRect();
        const x = (event.clientX - rect.left)/scale;
        const y = (event.clientY - rect.top)/scale;
        const node = nodes.find(
          (node) =>
            x >= node.x - radiusX &&
            x <= node.x + radiusX &&
            y >= node.y - radiusY &&
            y <= node.y + radiusY);                
      	event.preventDefault();
        const currentTime = new Date().getTime();
        const tapLength = currentTime - lastTouchTime;
        lastTouchTime = currentTime;
        if (tapLength < 500 && tapLength > 100) {//double click event
          hiddenInput.focus(); 
          if (node) {
            var ev = document.createEvent('HTMLEvents');
          } else {
            addNode(x, y);redraw()}
        } else {
          if (node) {
            pan=false
            selectedNodeIndex = nodes.indexOf(node);   
            hiddenInput.value=node.label;
            redraw();drag=1
          } else {
            pan=true;
            drag=1;
            }}
        lastx=x;lasty=y;
      }

      function handlePointerMove(event) {
        event.preventDefault();
        for (var i = 0; i < evCache.length; i++) {
          if (event.pointerId === evCache[i].pointerId) {
            evCache[i] = event;}
            }
        if (evCache.length > 1)  {
          var curDiff = Math.sqrt(Math.pow(evCache[1].clientX - evCache[0].clientX, 2) + Math.pow(evCache[1].clientY - evCache[0].clientY, 2));
          const oldscale=scale
          if (prevDiff > 0) {scale += 0.01*(curDiff-prevDiff);};
          moveNode(0 ,(canvas.width*0.5*oldscale/scale-canvas.width*0.5)/oldscale,
            (canvas.height*0.5*oldscale/scale-canvas.height*0.5)/oldscale);
          prevDiff = curDiff;
          zoomSlider.value = scale;
          event=evCache[0];
          }
        else if (drag) {
          if (selectedNodeIndex == -1) {return;}
          const rect = canvas.getBoundingClientRect();
          const x = (event.clientX - rect.left)/scale;
          const y = (event.clientY - rect.top)/scale;
          const dx = x - lastx;
          const dy = y - lasty;
          if (pan ==false) {
          moveNode(selectedNodeIndex , dx, dy);
          hiddenInput.blur();}
          else {moveNode(0 , dx, dy);}
          lastx=x;lasty=y;}
        redraw();
        }

      function moveNode(index, dx, dy) {
        nodes[index].x += dx;
        nodes[index].y += dy;
        nodes[index].children.forEach((childIndex) => {
          moveNode(childIndex, dx, dy);
        });}
      
      function deleteSelectedNode(event) {
        if (selectedNodeIndex === 0) {
          selectedNodeIndex = -1;
          nodes.splice(0);
        } else { 
          torm=[];        
          const prentNodeIndex = nodes.findIndex((prent) => prent.children.includes(selectedNodeIndex));          
          const nodeChildIndex = nodes[prentNodeIndex].children.indexOf(selectedNodeIndex);
          console.log('before nodes:', nodes);
          deleteSubtree(selectedNodeIndex); //get array of torm
          torm.push(selectedNodeIndex)
          torm.sort((a, b) => b - a);
          for (var i = 0; i < torm.length; i++) {
                nodes.splice(torm[i], 1);
                nodes.forEach((node) => {
                  for (var j = 0; j < node.children.length; j++) {
                    if (node.children[j] > torm[i]) {
                      node.children[j]--;}}
                });}
          nodes[prentNodeIndex].children.splice(nodeChildIndex, 1);
          selectedNodeIndex = prentNodeIndex;}           
          redraw();}

      function deleteSubtree(index) {
        nodes[index].children.forEach((childIndex) => {
          torm.push(childIndex);
          deleteSubtree(childIndex);});}
          
      function handlePointerUp(event) {
        event.preventDefault();
        pan=0;
        if (evCache.length < 2) {prevDiff = -1;drag=0;};
        for (var i = 0; i < evCache.length; i++) {
          if (evCache[i].pointerId == event.pointerId) {
            evCache.splice(i, 1);}
            }
        }
      function handleKeys(event) {if (selectedNodeIndex !== -1) {nodes[selectedNodeIndex].label = hiddenInput.value;redraw();}}   
      canvas.addEventListener("pointerdown", handlePointerDown);
      canvas.addEventListener("pointermove", handlePointerMove);
      canvas.addEventListener("pointerup", handlePointerUp);
      canvas.addEventListener("mouseout", handlePointerUp); 
      hiddenInput.addEventListener('keydown', handleKeys);
      hiddenInput.addEventListener("keyup", handleKeys);
      deleteButton.addEventListener("click", deleteSelectedNode);
      zoomSlider.addEventListener("input", function() {
        const oldscale=scale
        scale = parseFloat(this.value);
        moveNode(0 ,(canvas.width*0.5*oldscale/scale-canvas.width*0.5)/oldscale,
          (canvas.height*0.5*oldscale/scale-canvas.height*0.5)/oldscale);
        redraw();}); 
      canvas.addEventListener('wheel', function(event) {
           event.preventDefault();
           const delta = Math.sign(event.deltaY);
           const oldscale=scale
           if (delta === 1) {scale *= 1.05;}
           else if (delta === -1) {scale /= 1.05;}
           moveNode(0 ,(canvas.width*0.5*oldscale/scale-canvas.width*0.5)/oldscale,
              (canvas.height*0.5*oldscale/scale-canvas.height*0.5)/oldscale);
           zoomSlider.value = scale;
           redraw();});
        
    </script>
  </body>
</html>
